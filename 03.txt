在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信： 
1.委托delegation； 
2.通知中心Notification Center； 
3.键值观察key value observing，KVO 

delegate的优势：

  1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。

  2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误

  3.协议必须在controller的作用域范围内定义

  4.在一个应用中的控制流程是可跟踪的并且是可识别的；

  5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates

  6.没有第三方对象要求保持/监视通信过程。

  7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller

  缺点：

  1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义

  2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash

  3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。


notification 优势：

    1.不需要编写多少代码，实现比较简单;

    2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单;

    3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息

    缺点：

    1.在编译期不会检查通知是否能够被观察者正确的处理；
    2.在释放注册的对象时，需要在通知中心取消注册；

    3.在调试的时候应用的工作以及控制过程难跟踪；

    4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；

    5.controller和观察者需要提前知道通知名称UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；

    6.通知发出后，controller不能从观察者获得任何的反馈信息。


KVO 优点：

     1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；

     2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；

     3.能够提供观察的属性的最新值以及先前值；

     4.用key paths来观察属性，因此也可以观察嵌套对象；

     5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察

    缺点：

     1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；

     2.对属性重构将导致我们的观察代码不再可用；

     3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；

     4.当释放观察者时不需要移除观察者。
