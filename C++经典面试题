c++

1.new delete,malloc free关系

   (1)malloc和new都是在堆上分配内存。栈区的内存分配是系统自动分配释放的，主要存放函数的参数值、局部变量的值等。

(2)Malloc和free在C程序中使用，而C++程序中使用new和delete，删除数组delete[]p，指针释放后，要将指针置空。

(3)New和delete可以调用构造函数和析构函数。

(4)Malloc是函数，new是关键字。

(5)Malloc不能赋初值，new可以，如int *p = new int(2).代表分配一个int型的内存空间，并赋初值2.如果new int ()代表赋初值0，
new int[10]代表分配10个int.

(6)Malloc返回的指针是void *类型，而new返回的指针是它分配空间的类型。



2.delete与 delete []区别
delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，
它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

MemTest *mTest1=new MemTest[10];

MemTest *mTest2=new MemTest;
a
Int *pInt1=new int [10];
a
Int *pInt2=new int;

delete[]pInt1; //-1-

delete[]pInt2; //-2-

delete[]mTest1;//-3-

delete[]mTest2;//-4-

在-4-处报错。

这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。
delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。




2.子类析构时要调用父类的析构函数吗

构造时，先构造父类，再构造子类部分，因此父类和子类的构造函数都会被调用；
析构时，要分情况：
（1）（父类析构函数不是虚函数）使用父类指针指向子类对象，析构该子类对象时，只会调用父类析构函数，因为不具多态性；代码理解：
class child:public parent{};
parent *p = new child();
delete p;   //调用父类析构函数，子类析构函数不会被调用

（2）上面存在一个问题，如果子类也分配的资源就会导致无法释放，使用虚函数可以解决上述问题。

class parent{
	virtual	~parent();
};
class child:public parent
{
	~child();
};
parent *p = new child();
delete p;   //先调用子类的析构函数，再调用父类的析构函数

（3）对于第一种非虚函数的情况，如果是用子类指针指向子类对象，那么会先调用子类析构函数，再调用父类析构函数，子类释放子类中分配的，
父类分配父类中分配的。

class child:public parent{};
child*p = new child();
delete p;   //先调用子类的析构函数，再调用父类的析构函数


4.多态 虚函数 纯虚函数的理解

C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。
如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

  1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  

  2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  

  3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  

  4：多态用虚函数来实现，结合动态绑定.  

  5:纯虚函数是虚函数再加上 = 0；  

  6：抽象类是指包括至少一个纯虚函数的类。

纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。

6.求下面函数的返回值（微软）
int func(x) 

{ 

int countx = 0; 

while(x) 

{ 

countx ++; 

x = x&(x-1); 

} 

return countx; 

} 

假定x = 9999。 答案：8

思路：将x转化为2进制，看含有的1的个数。




6.将 引用 作为函数参数有那些特点

（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，
所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，
需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，
用引用比用一般变量传递参数的效率和所占空间都好。
（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，
这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。



7.结构和联合的区别

1、结构体的定义
   struct 结构体名
   {
       数据类型1 成员名1；
       数据类型2 成员名2；
       ......
   };
2、联合体的定义
   union 联合体名
   {
       数据类型1 成员名1；
       数据类型2 成员名2；
   }；
3、两者之间的区别：
 （1）在同一时刻，结构体的每个成员都有值，但是联合体在同一时刻只有一个成员有值（或理解为结构体的sizeof是所有成员的和，
 而联合体的sizeof等于其最长的成员的sizeof）；
 （2）当对结构体变量的其中一个成员进行修改时，对其他成员没有影响，但是修改联合体时，则会将原来的成员值覆盖。
 
 
 
 
 
 
 
 8.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。
如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。
那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，
是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，
这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。




9.c++ 是不是类型安全的
不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

10.main 函数执行以前，还会执行什么代码

全局对象的构造函数会在main 函数之前执行。



main函数执行之前，主要就是初始化系统相关资源：

1.设置栈指针

2.初始化static静态和global全局变量，即data段的内容

3.将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容

4.运行全局构造器，估计是C++中构造函数之类的吧

5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数



（1）全局对象的析构函数会在main函数之后执行； 

（2）可以用_onexit 注册一个函数，它会在main 之后执行; 

11.描述以下内存分配的方式以及区别

1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。
动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。



C++的4种内存分配方式 ：堆、栈、自由存储区、全局/静态存储区和常量存储区

 

　　栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，
  位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。

 

　　堆，就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个 new 就要对应一个 delete。
  如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。堆可以动态地扩展和收缩。

 

　　自由存储区，就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的。

 

　　全局/静态存储区， 全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（
  初始化的全局变量和静态变量在一块区域，未初始化 的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 
  void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里 面没有这个区分了，他们共同占用同一块内存区。

 

　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）

 

　　明确区分堆与栈

　　在 BBS 上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。


堆和栈究竟有什么区别？

　　主要的区别由以下几点：

　　1、管理方式不同；

　　2、空间大小不同；

　　3、能否产生碎片不同；

　　4、生长方向不同；

　　5、分配方式不同；

　　6、分配效率不同；

 

　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

 

　　空间大小： 一般来讲在 32 位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，
  一般都是有一定的空间大小的，例 如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：打开工程，
  依次操作菜单如 下：Project->Setting->Link，在 Category 中选中 Output，然后在 Reserve 中设定堆栈的最 大值和 commit。
  注意：reserve 最小值为 4Byte；commit 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可 能增加内存的开销和启动时间。

 

　　碎片问题： 对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，
  则不会存在这个问题，因为栈 是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，
  在他上面的后进的栈内容已经被弹出，详细的可以参 考数据结构，这里我们就不再一一讨论了。

 

　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

 

　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。
  动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

 

　　分配效率： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，
  这就决定了栈的效率比较高。堆则 是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（
  具体的算法可以参考数据结构/操作系统）在堆内存中 搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），
  就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够 大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

　 　从这里我们可以看到，堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；
   由于可能引发 用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，
   函数调用过程中的参数，返回地 址，EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。

　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

　 　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，
   产生以想不到的结果, 就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候 debug 可是相当困难的 ：）

　　对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆，呵呵，清楚了？

 

　　static 用来控制变量的存储方式和可见性

　 　函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，
   这样就产生了一个问 题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，
   但定义为一个全局变量有许多缺点，最明显的缺点 是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此 函数控制）。
   需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装 性，即要求此成员隐藏在类的内部，对外不可见。

 

　　static 的内部机制：

　 　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
   这样，它的空间分配有 三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；
   三是应用程序的 main(）函数前的全 局数据声明和定义处。

　 　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，
   所以在类 声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。

　　static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，
  要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

 

　　static 的优势：

　 　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。
   静态数据成员的值对每个对象都是一样，但它 的 值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，
   这样可以提高时间效率。引用静态数据成员时，采用如下格式：

　　<类名>::<静态成员名>

　　如果静态数据成员的访问权限允许的话(即 public 的成员)，可在程序中，按上述格式来引用静态数据成员。

　　

Ps：

　　(1) 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。

　　(2) 不能将静态成员函数定义为虚函数。

　　(3) 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，
  函数地址类型是一个“nonmember 函数指针”。

　 　(4) 由于静态成员函数没有 this 指针，所以就差不多等同于 nonmember 函数，结果就产生了一个意想不到的好处：
   成为一 个 callback 函数，使得我们得以将 c++ 和 c-based x window 系统结合，同时也成功的应用于线程函数身上。

　　(5) static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。

　　(6) 静态数据成员在<定义或说明>时前面加关键字 static。

　　(7) 静态数据成员是静态存储的，所以必须对它进行初始化。

　　(8) 静态成员初始化与一般数据成员初始化不同：

　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；

　　初始化时不加该成员的访问权限控制符 private、public；

　　初始化时使用作用域运算符来标明它所属类；

　　所以我们得出静态数据成员初始化的格式：

　　<数据类型><类名>::<静态数据成员名>=<值>

 　 　(9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：
    我们说静态成员为父类和子类共享，但我 们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：
    name-mangling 用以生成唯一的标志。




12.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
答案：

BOOL : if ( !a ) or if(a)

int : if ( a == 0)

float : const EXPRESSION EXP = 0.000001

if ( a < EXP && a >-EXP)

pointer : if ( a != NULL) or if(a == NULL)


13.请说出const 与define 有何优点
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，
并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

14.int (*s[10])(int) 表示的是什么？
int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。


1、首先*s[10]  是一个指针数组，s 是一个含有10个指针的数组，故可以这样来看这条声明语句：假设 p 等价于 s[10],声明语句变为 int (*p)(int);
2、观察 int (*p)(int), 从名字开始，p前面有一个 * ，因此 p 是指针，有侧是形参列表，表示p指向的是函数，在观察左侧，函数返回的是 int；
3、则 int (*p)(int) 解读为：函数指针，指向一个 int func(int param) 的函数；



15 int id[sizeof(unsigned long)];这个对吗？为什么？

 答案:正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。
 
 
 25题：引用与指针有什么区别？

【参考答案】                         
1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

 

 

26题：const  与 #define 的比较 ，const有什么优点?

 【参考答案】

（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。

（2）  有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

 

 

 

27题：复杂声明

void * ( * (*fp1)(int))[10];

float (*(* fp2)(int,int,int))(int);

int (* ( * fp3)())[10]();

分别表示什么意思？
【标准答案】                                                           

1.void * ( * (*fp1)(int))[10];   fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，
这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。

2.float (*(* fp2)(int,int,int))(int);   fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，
这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。

3.int (* ( * fp3)())[10]();   fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，
这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。

 

 

 

28题：内存的分配方式有几种?
【参考答案】

一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。

二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

 

 

29题：基类的析构函数不是虚函数，会带来什么问题？
【参考答案】派生类的析构函数用不上，会造成资源的泄漏。

 

30题：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
【参考答案】

生命周期不同：

全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 

操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

