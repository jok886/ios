1.    面向对象的程序设计思想是什么?

答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象。

2.    什么是类?
答：把一些具有共性的对象归类后形成一个集合，也就是所谓的类。

3.    对象都具有的两方面特征是什么?分别是什么含义?
答：对象都具有的特征是：静态特征和动态特征。
静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）


4.    在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义?
答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率。

5.    在类的内部定义成员函数的函数体，这种函数会具备那种属性?
答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换。


6.    成员函数通过什么来区分不同对象的成员数据?为什么它能够区分?
答：通过this指针指向对象的首地址来区分的。


7.    C++编译器自动为类产生的四个缺省函数是什么?
答：默认构造函数，拷贝构造函数，析构函数，赋值函数。

8.    拷贝构造函数在哪几种情况下会被调用?
答：
1.当类的一个对象去初始化该类的另一个对象时；
2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；
3.如果函数的返回值是类对象，函数调用完成返回时。


9.    构造函数与普通函数相比在形式上有什么不同?（构造函数的作用，它的声明形式来分析）
答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的。
构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。

10.  什么时候必须重写拷贝构造函数?
答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。

11.  构造函数的调用顺序是什么?
答： 1.先调用基类构造函数
2.按声明顺序初始化数据成员
3.最后调用自己的构造函数。

12.  哪几种情况必须用到初始化成员列表?
答： 1.类的成员是常量成员初始化；
2.类的成员是对象成员初始化，而该对象没有无参构造函数。
3.类的成员为引用时。


13.  什么是常对象?
答：常对象是指在任何场合都不能对其成员的值进行修改的对象。


14.  静态函数存在的意义?
答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；
当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数。


15.  在类外有什么办法可以访问类的非公有成员?
答：友元，继承，公有成员函数。


16.  什么叫抽象类?
答：不用来定义对象而只作为一种基本类型用作继承的类。

17.  运算符重载的意义?
答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致。


18.  不允许重载的5个运算符是哪些?
答：1.    .*（成员指针访问运算符号）
2.    ：：域运算符
3.    Sizeof 长度运算符号
4.    ?：条件运算符号
5.  .（成员访问符）


19.  运算符重载的三种方式?
答：普通函数，友元函数，类成员函数。

20.  流运算符为什么不能通过类的成员函数重载?一般怎么解决?
答：因为通过类的成员函数重载必须是运算符的第一个是自己，而对流运算的重载要求第一个参数是流对象。所以一般通过友元来解决。
21.  赋值运算符和拷贝构造函数的区别与联系?
答： 相同点：都是将一个对象copy到另一个中去。
不同点：拷贝构造函数涉及到要新建立一个对象。


22.  在哪种情况下要调用该类的析构函数?
答：对象生命周期结束时。

23.  对象间是怎样实现数据的共享的?
答：通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有。


24.  友元关系有什么特性?
答：单向的，非传递的，不能继承的。

25.  对对象成员进行初始化的次序是什么?
答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的。


26.  类和对象之间的关系是什么?
答：类是对象的抽象，对象是类的实例。


27.  对类的成员的访问属性有什么?
答：public，protected，private。

28．const char *p和char *  const p; 的区别
答： 如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。


29.  是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
答： virtual修饰符会被隐形继承的。
virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态。


30.  函数重载是什么意思?它与虚函数的概念有什么区别?
答：函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。但是记住：不能仅仅通过函数返回值不同来实现函数重载。而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。它体现的是一个纵向的概念，也即在基类和派生类间实现。


31.  构造函数和析构函数是否可以被重载,为什么?
答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。


32.  如何定义和实现一个类的成员函数为回调函数?
答：所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。
定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别。


33.  虚函数是怎么实现的?
答：简单说来使用了虚函数表.


34.  抽象类不会产生实例，所以不需要有构造函数。 错


35.  从一个模板类可以派生新的模板类，也可以派生非模板类。 对


36.  main 函数执行以前，还会执行什么代码?
答案：全局对象的构造函数会在main 函数之前执行。


37.  当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。


38.  delete与 delete []区别：
答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。


39．子类析构时要调用父类的析构函数吗?
答：会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了


40.  继承的优缺点。

答：
1、类继承是在编译时刻静态定义的，且可直接使用，
2、类继承可以较方便地改变父类的实现。
缺点：
1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。
41.  解释堆和栈的区别。 
答：栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。


42.  一个类的构造函数和析构函数什么时候被调用,是否需要手工调用?
答：构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用。


43.  何时需要预编译：
答：总是使用不经常改动的大型代码体。
程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。


44.  多态的作用?
答：主要是两个：
1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用


45.  虚拟函数与普通成员函数的区别?内联函数和构造函数能否为虚拟函数?
答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数。

46.  构造函数和析构函数的调用顺序? 析构函数为什么要虚拟?
答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏。
47. C++中类型为private的成员变量可以由哪些函数访问?
答：只可以由本类中的成员函数和友元函数访问
48.  请说出类中private，protect，public三种访问限制类型的区别
答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问.
49.  类中成员变量怎么进行初始化?
答：可以通过构造函数的初始化列表或构造函数的函数体实现。
50.  在什么时候需要使用“常引用”? 
答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
51.  引用与指针有什么区别?
答 、1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。
3) 不存在指向空值的引用，但是存在指向空值的指针。
52.  描述实时系统的基本特性
答 、在特定时间内完成特定的任务，实时性与可靠性。
54.  全局变量和局部变量在内存中是否有区别?如果有，是什么区别?
答 、全局变量储存在静态数据区，局部变量在堆栈中。
55.  堆栈溢出一般是由什么原因导致的?
答 、没有回收垃圾资源
56.  什么函数不能声明为虚函数?
答：构造函数（constructor）
57.  IP地址的编码分为哪俩部分?
答 IP地址由两部分组成，网络号和主机号。
58.  不能做switch()的参数类型是：
答 、switch的参数不能为实型。
59.  如何引用一个已经定义过的全局变量?
答 、可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错
60.  对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
答 、c用宏定义，c++用inline
61.  C++是不是类型安全的?
答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)
62.  当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，请解释一下编译器为什么没有让它为零。
答案：为1。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。
63.  简述数组与指针的区别?
答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
(1)修改内容上的区别
char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。
64.  C++函数中值的传递方式
答：有三种方式：值传递、指针传递、引用传递
65.  内存的分配方式
答：分配方式有三种，
1、 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量。
2、 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限。
3、 堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存。
66.  extern“C”有什么作用?
答：Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了。
Extern “C”主要使用正规DLL函数的引用和导出 和 在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可。可以用一句话概括extern “C”这个声明的真实目的：实现C++与C及其它语言的混合编程。
67.  用什么函数开启新进程、线程。
答案：
线程：CreateThread/AfxBeginThread等
进程：CreateProcess等
68.  SendMessage和PostMessage有什么区别
答案：SendMessage是阻塞的，等消息被处理后，代码才能走到SendMessage的下一行。PostMessage是非阻塞的，不管消息是否已被处理，代码马上走到PostMessage的下一行。
69.  CMemoryState主要功能是什么
答案：查看内存使用情况，解决内存泄露问题。
70.  #include <filename.h>和 #include “filename.h” 有什么区别?
答：对于#include <filename.h> ，编译器从标准库路径开始搜索 filename.h
对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h
71.  处理器标识#error的目的是什么?
答：编译时输出一条错误信息，并中止继续编译。
72.  #if!defined(AFX_…_HADE_H)
 #define(AFX_…_HADE_H)
…
#endif作用?
答：防止该头文件被重复引用。
73. 在定义一个宏的时候要注意什么?
答：定义部分的每个形参和整个表达式都必须用括号括起来，以避免不可预料的错误发生
74.  数组在做函数实参的时候会转变为什么类型?
答：数组在做实参时会变成指针类型。
75.  系统会自动打开和关闭的3个标准的文件是?
(1)   标准输入—-键盘—stdin
(2)   标准输出—-显示器—stdout
(3)   标准出错输出—-显示器—stderr
76.  .在Win32下 char, int, float, double各占多少位?
(1)   Char       占用8位
(2)   Int      占用32位
(3)   Float    占用32位
(4)   Double   占用64位
77.  strcpy()和memcpy()的区别?
答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以’\0’结束，但memcpy()必须指定拷贝的长度。
78.  说明define和const在语法和含义上有什么不同?
答：(1)   #define是C语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；
(2)   Const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度。
79.  说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用?
答：字符常量是指单个字符，字符串常量以‘\0’结束，使用运算符sizeof计算多占一字节的存储空间。
80.  简述全局变量的优缺点?
答：全局变量也称为外部变量，它是在函数外部定义的变量，它属于一个源程序文件，它保存上一次被修改后的值，便于数据共享，但不方便管理，易引起意想不到的错误。
81.  总结static的应用和作用?
答：（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
82.  总结const的应用和作用?
答： （1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”
83.  什么是指针?谈谈你对指针的理解?
答：指针是一个变量，该变量专门存放内存地址；
指针变量的类型取决于其指向的数据类型，在所指数据类型前加*
指针变量的特点是它可以访问所指向的内存。
84.  什么是常指针，什么是指向常变量的指针?
答：常指针的含义是该指针所指向的地址不能变，但该地址所指向的内容可以变化，使用常指针可以保证我们的指针不能指向其它的变量，
指向常变量的指针是指该指针的变量本身的地址可以变化，可以指向其它的变量，但是它所指的内容不可以被修改。指向长变量的指针定义，
85.  函数指针和指针函数的区别?
答：函数指针是指向一个函数入口的指针；指针函数是函数的返回值是一个指针类型。
87.  简述Debug版本和Release版本的区别?
答：Debug版本是调试版本，Release版本是发布给用户的最终非调试的版本，
88.  指针的几种典型应用情况?
答：
int *p[n];—–指针数组，每个元素均为指向整型数据的指针。
int (*)p[n];—p为指向一维数组的指针，这个一维数组有n个整型数据。
int *p();——函数带回指针，指针指向返回的值。
int (*)p();—-p为指向函数的指针。
89.  static函数与普通函数有什么区别?
答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
90.  struct(结构) 和 union(联合)的区别?
答：1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
2. 对于联合的不同成员赋值, 将会对其它成员重写,  原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
91.  class 和 struct 的区别?
答：struct 的成员默认是公有的，而类的成员默认是私有的。
92.  简述枚举类型?
答：枚举方便一次定义一组常量，使用起来很方便；
93.  assert()的作用?
答：ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。
94.  局部变量和全局变量是否可以同名?
答：能。局部会屏蔽全局。要用全局变量，需要使用”::”(域运算符)。
95.  程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。
96.  在什么时候使用常引用?
答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
97.  类的声明和实现的分开的好处?
答：1.    起保护作用；
2.    提高编译的效率。
98.  windows消息系统由哪几部分构成?
答：由一下3部分组成：
1.    消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；
2.    消息循环：应用程序通过消息循环不断获取消息、处理消息。
3.    消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。
99.  什么是消息映射?
答：消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。
100. 什么是UDP和TCP的区别是什么?
答：TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
UDP全称为用户报文协议，它可以提供非连接的不可靠的点到多点的通信。用TCP还是UDP，那要看你的程序注重哪一个方面?可靠还是快速?
